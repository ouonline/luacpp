#include "lua_state.h"
#include "lua_table.h"
#include "lua_function.h"
using namespace std;

namespace luacpp {

static void DummyDeleter(lua_State*) {}

LuaState::LuaState(lua_State* l, bool is_owner) {
    if (is_owner) {
        m_l = shared_ptr<lua_State>(l, lua_close);
        luaL_openlibs(l);
    } else {
        m_l = shared_ptr<lua_State>(l, DummyDeleter);
    }

    SetupGcTable();
}

LuaState::~LuaState() {
    if (m_l.get()) { // not moved
        luaL_unref(m_l.get(), LUA_REGISTRYINDEX, m_gc_table_ref);
    }
}

LuaObject LuaState::Get(const char* name) const {
    auto l = m_l.get();
    lua_getglobal(l, name);
    LuaObject ret(l, -1);
    lua_pop(l, 1);
    return ret;
}

void LuaState::Set(const char* name, const LuaObject& lobj) {
    lobj.PushSelf();
    lua_setglobal(m_l.get(), name);
}

LuaObject LuaState::CreateObject(const char* str, const char* name) {
    auto l = m_l.get();
    lua_pushstring(l, str);
    LuaObject ret(l, -1);
    if (name) {
        lua_setglobal(m_l.get(), name);
    } else {
        lua_pop(l, 1);
    }
    return ret;
}

LuaObject LuaState::CreateObject(const char* str, uint64_t len, const char* name) {
    auto l = m_l.get();
    lua_pushlstring(l, str, len);
    LuaObject ret(l, -1);
    if (name) {
        lua_setglobal(l, name);
    } else {
        lua_pop(l, 1);
    }
    return ret;
}

LuaObject LuaState::CreateObject(lua_Number value, const char* name) {
    auto l = m_l.get();
    lua_pushnumber(l, value);
    LuaObject ret(l, -1);
    if (name) {
        lua_setglobal(l, name);
    } else {
        lua_pop(l, 1);
    }
    return ret;
}

LuaTable LuaState::CreateTable(const char* name) {
    auto l = m_l.get();

    lua_newtable(l);
    LuaTable ret(l, -1);

    if (name) {
        lua_setglobal(l, name);
    } else {
        lua_pop(l, 1);
    }

    return ret;
}

bool LuaState::DoString(const char* chunk, string* errstr,
                        const function<bool (int, const LuaObject&)>& callback) {
    auto l = m_l.get();
    bool ok = (luaL_loadstring(l, chunk) == LUA_OK);
    if (!ok) {
        if (errstr) {
            *errstr = lua_tostring(l, -1);
        }
        lua_pop(l, 1);
        return false;
    }

    LuaFunction f(l, -1);
    ok = f.Exec(callback, errstr);
    lua_pop(l, 1); // function generated by luaL_loadstring()
    return ok;
}

bool LuaState::DoFile(const char* script, string* errstr,
                      const function<bool (int, const LuaObject&)>& callback) {
    auto l = m_l.get();
    bool ok = (luaL_loadfile(l, script) == LUA_OK);
    if (!ok) {
        if (errstr) {
            *errstr = lua_tostring(l, -1);
        }
        lua_pop(l, 1);
        return false;
    }

    LuaFunction f(l, -1);
    ok = f.Exec(callback, errstr);
    lua_pop(l, 1); // function generated by luaL_loadfile()
    return ok;
}

}
