#include "lua_state.h"
#include "lua_table.h"
#include "lua_function.h"
using namespace std;

namespace luacpp {

static inline void DummyDeleter(lua_State*) {}

LuaState::LuaState(LuaState&& rhs) {
    m_l = rhs.m_l;
    m_deleter = rhs.m_deleter;
    m_gc_table_ref = rhs.m_gc_table_ref;

    rhs.m_l = nullptr;
    rhs.m_deleter = DummyDeleter;
    rhs.m_gc_table_ref = LUA_REFNIL;
}

LuaState& LuaState::operator=(LuaState&& rhs) {
    if (&rhs == this) {
        return *this;
    }

    if (m_l) {
        m_deleter(m_l);
    }

    m_l = rhs.m_l;
    m_deleter = rhs.m_deleter;
    m_gc_table_ref = rhs.m_gc_table_ref;

    rhs.m_l = nullptr;
    rhs.m_deleter = DummyDeleter;
    rhs.m_gc_table_ref = LUA_REFNIL;

    return *this;
}

static inline int SetupGcTable(lua_State* l) {
    lua_newtable(l);
    lua_pushcfunction(l, GenericDestructor<DestructorObject>);
    lua_setfield(l, -2, "__gc");
    return luaL_ref(l, LUA_REGISTRYINDEX);
}

LuaState::LuaState(lua_State* l, bool is_owner) {
    m_l = l;
    if (is_owner) {
        luaL_openlibs(l);
        m_deleter = lua_close;
    } else {
        m_deleter = DummyDeleter;
    }

    m_gc_table_ref = SetupGcTable(l);
}

LuaState::~LuaState() {
    if (m_l) { // not moved
        luaL_unref(m_l, LUA_REGISTRYINDEX, m_gc_table_ref);
        m_deleter(m_l);
    }
}

LuaObject LuaState::Get(const char* name) const {
    lua_getglobal(m_l, name);
    LuaObject ret(m_l, -1);
    lua_pop(m_l, 1);
    return ret;
}

void LuaState::Set(const char* name, const LuaObject& lobj) {
    lobj.PushSelf();
    lua_setglobal(m_l, name);
}

LuaObject LuaState::CreateObject(const char* str, const char* name) {
    lua_pushstring(m_l, str);
    LuaObject ret(m_l, -1);
    if (name) {
        lua_setglobal(m_l, name);
    } else {
        lua_pop(m_l, 1);
    }
    return ret;
}

LuaObject LuaState::CreateObject(const char* str, uint64_t len, const char* name) {
    lua_pushlstring(m_l, str, len);
    LuaObject ret(m_l, -1);
    if (name) {
        lua_setglobal(m_l, name);
    } else {
        lua_pop(m_l, 1);
    }
    return ret;
}

LuaObject LuaState::CreateObject(lua_Number value, const char* name) {
    lua_pushnumber(m_l, value);
    LuaObject ret(m_l, -1);
    if (name) {
        lua_setglobal(m_l, name);
    } else {
        lua_pop(m_l, 1);
    }
    return ret;
}

LuaTable LuaState::CreateTable(const char* name) {
    lua_newtable(m_l);
    LuaTable ret(m_l, -1);

    if (name) {
        lua_setglobal(m_l, name);
    } else {
        lua_pop(m_l, 1);
    }

    return ret;
}

bool LuaState::DoString(const char* chunk, string* errstr,
                        const function<bool (int, const LuaObject&)>& callback) {
    bool ok = (luaL_loadstring(m_l, chunk) == LUA_OK);
    if (!ok) {
        if (errstr) {
            *errstr = lua_tostring(m_l, -1);
        }
        lua_pop(m_l, 1);
        return false;
    }

    LuaFunction f(m_l, -1);
    ok = f.Exec(callback, errstr);
    lua_pop(m_l, 1); // function generated by luaL_loadstring()
    return ok;
}

bool LuaState::DoFile(const char* script, string* errstr,
                      const function<bool (int, const LuaObject&)>& callback) {
    bool ok = (luaL_loadfile(m_l, script) == LUA_OK);
    if (!ok) {
        if (errstr) {
            *errstr = lua_tostring(m_l, -1);
        }
        lua_pop(m_l, 1);
        return false;
    }

    LuaFunction f(m_l, -1);
    ok = f.Exec(callback, errstr);
    lua_pop(m_l, 1); // function generated by luaL_loadfile()
    return ok;
}

}
